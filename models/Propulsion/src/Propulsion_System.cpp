/********************************* TRICK HEADER *******************************
PURPOSE: (Simulate A Motor)
LIBRARY DEPENDENCY:
    ((Propulsion_System.o)
     (hall_thruster.o)
     (xenon_tank.o))
*******************************************************************************/

/*
PURPOSE:    This module provides a framework for communication between xenon tanks and thrusters,
            specifically designed for a spacecraft with seven thrusters located in the PPE (Power and
            Propulsion Element). It calculates the forces generated by the thrusters and manages xenon
            massflow for propulsion.

NOTE:       This code is tailored to a specific spacecraft model and configuration. Future changes will
            be required to support different numbers of thrusters or new thruster positions on different
            spacecrafts.

TERMS USED:
    -> thrusters - array of 7 thrusters used in the propulsion system.
    -> tanks - array of 3 xenon tanks providing propellant for the thrusters.
    -> total_massflow - total mass flow rate of the system.
    -> available_mass - total mass available in all tanks.
    -> orientation - the direction each thruster is facing.
    -> position - the position of each thruster relative to the satellite.
    -> Vector3d - 3D vector class from Eigen library used to store forces and positions.
*/

#include <iostream>
#include "../include/Propulsion_System.hh"
//#include "../../../Lib/eigen-3.4.0/Eigen/Dense" //include Eigen Library directory here

using namespace std;

Propulsion_System::Propulsion_System()
    //Description:   Default constructor initializes the total massflow to zero and sets the orientation of all thrusters.
    //Preconditions: None
    //Postconditions: Total massflow is set to zero, and thruster orientations are initialized. Available mass is calculated from the xenon tanks.
{
    total_massflow = 0.0;
    for (int i = 0; i < 7; i++) {
        thrusters[i].set_refrence_ori(0, 0, -1);
    }
    available_mass = tanks[0].getmass() + tanks[1].getmass() + tanks[2].getmass();
}

Propulsion_System::Propulsion_System(double length, double hight, double depth, double D1, double D2)
    //Description:   Overloaded constructor initializes thruster positions based on spacecraft dimensions and initializes thruster orientation.
    //Preconditions: All dimensions (length, height, depth) must be positive.
    //Postconditions: Thruster positions and orientations are set, and available mass is calculated.
{
    total_massflow = 0.0;

    thrusters[0].set_refrence_pos(0, 0, -depth / 2);
    thrusters[1].set_refrence_pos(length / 2, 0, -depth / 2);
    thrusters[2].set_refrence_pos(-length / 2, 0, -depth / 2);
    thrusters[3].set_refrence_pos(length / 2 + D1, 0, -depth / 2);
    thrusters[4].set_refrence_pos(length / 2 + D2, 0, -depth / 2);
    thrusters[5].set_refrence_pos(-length / 2 - D1, 0, -depth / 2);
    thrusters[6].set_refrence_pos(-length / 2 - D2, 0, -depth / 2);

    for (int i = 0; i < 7; i++) {
        thrusters[i].set_refrence_ori(0, 0, -1);
    }

    available_mass = tanks[0].getmass() + tanks[1].getmass() + tanks[2].getmass();
}

void Propulsion_System::set_all_thruster_ref_pos(double length, double hight, double depth, double D1, double D2)
    //Description:   Sets the positions of all thrusters relative to the spacecraft.
    //Preconditions: Positive values for dimensions must be provided.
    //Postconditions: Thruster positions are updated.
{
    thrusters[0].set_refrence_pos(0, 0, -depth / 2);
    thrusters[1].set_refrence_pos(length / 2, 0, -depth / 2);
    thrusters[2].set_refrence_pos(-length / 2, 0, -depth / 2);
    thrusters[3].set_refrence_pos(length / 2 + D1, 0, -depth / 2);
    thrusters[4].set_refrence_pos(length / 2 + D2, 0, -depth / 2);
    thrusters[5].set_refrence_pos(-length / 2 - D1, 0, -depth / 2);
    thrusters[6].set_refrence_pos(-length / 2 - D2, 0, -depth / 2);
}

void Propulsion_System::set_all_thruster_ref_ori(double orientation[3])
    //Description:   Sets the orientation of all thrusters using a 3D array.
    //Preconditions: A valid 3D orientation array must be provided.
    //Postconditions: Thruster orientations are updated.
{
    for (int i = 0; i < 7; i++) {
        thrusters[i].set_refrence_ori(orientation);
    }
}

void Propulsion_System::set_all_thruster_ref_ori(double x, double y, double z)
    //Description:   Sets the orientation of all thrusters using individual x, y, z components.
    //Preconditions: x, y, z components must be valid.
    //Postconditions: Thruster orientations are updated.
{
    for (int i = 0; i < 7; i++) {
        thrusters[i].set_refrence_ori(x, y, z);
    }
}

void Propulsion_System::set_all_thruster_ref_ori(Vector3d orientation)
    //Description:   Sets the orientation of all thrusters using an Eigen 3D vector.
    //Preconditions: A valid Vector3d for orientation must be provided.
    //Postconditions: Thruster orientations are updated.
{
    for (int i = 0; i < 7; i++) {
        thrusters[i].set_refrence_ori(orientation);
    }
}

void Propulsion_System::set_all_thruster_specs(double power, double discharge_voltage, double efficiency)
    //Description:   Sets the power, discharge voltage, and efficiency for all thrusters.
    //Preconditions: Valid specifications must be provided.
    //Postconditions: Thruster specifications are initialized.
{
    for (int i = 0; i < 7; i++) {
        thrusters[i].initialize_state(power, discharge_voltage, efficiency);
    }
}


void Propulsion_System::set_thruster_specs(int i, double power, double discharge_voltage, double efficiency)
    //Description:   Sets the power, discharge voltage, and efficiency for all thrusters.
    //Preconditions: Valid specifications must be provided.
    //Postconditions: Thruster specifications are initialized.
{
    thrusters[i].initialize_state(power, discharge_voltage, efficiency);
}

void Propulsion_System::update_all_pos_ori(double satellite_position[3], double rotation_matrix[3][3])
    //Description:   Updates the position and orientation of all thrusters based on the spacecraft's current position and orientation matrix.
    //Preconditions: Satellite position and rotation matrix must be provided.
    //Postconditions: Thruster positions and orientations are updated.
{
    for (int i = 0; i < 7; i++) {
        thrusters[i].update_pos_ori(satellite_position, rotation_matrix);
    }
}

void Propulsion_System::update_all_pos_ori(Vector3d satellite_position, Matrix3d rotation_matrix)
    //Description:   Overloaded version of update_all_pos_ori using Eigen vector and matrix.
    //Preconditions: Satellite position and rotation matrix must be provided.
    //Postconditions: Thruster positions and orientations are updated.
{
    for (int i = 0; i < 7; i++) {
        thrusters[i].update_pos_ori(satellite_position, rotation_matrix);
    }
}

void Propulsion_System::get_all_force(double F[3], double pos[3])
    //Description:   Calculates and returns the total force and position of all thrusters when active.
    //Preconditions: None
    //Postconditions: Total force and center of thrust position are calculated and returned in the provided arrays.
{
    Vector3d Total_F;
    Vector3d Total_pos;
    Vector3d Added_F;
    Vector3d Added_pos;

    Total_F.insert(0, 0, 0);
    Total_pos.insert(0, 0, 0);

    double num_on = 0;

    for (int i = 0; i < 7; i++) {
        if (thrusters[i].is_state_on()) {
            thrusters[i].get_force(available_mass, Added_F, Added_pos);
            num_on = num_on + 1.0;
        }
        Total_F = Total_F + Added_F;
        Total_pos = Total_pos + Added_pos;
    }
    Total_pos = Total_pos / num_on;

    for (int i = 0; i < 3; i++) {
        F[i] = Total_F[i];
        pos[i] = Total_pos[i];
    }
}

void Propulsion_System::get_all_force(Vector3d& F, Vector3d& pos)
    //Description:   Overloaded version of get_all_force using Eigen vectors.
    //Preconditions: None
    //Postconditions: Total force and center of thrust position are calculated and returned in Eigen vectors.
{
    Vector3d Total_F;
    Vector3d Total_pos;
    Vector3d Added_F;
    Vector3d Added_pos;

    Total_F.insert(0, 0, 0);
    Total_pos.insert(0, 0, 0);

    double num_on = 0;

    for (int i = 0; i < 7; i++) {
        if (thrusters[i].is_state_on()) {
            thrusters[i].get_force(available_mass, Added_F, Added_pos);
            num_on = num_on + 1.0;
        }
        Total_F = Total_F + Added_F;
        Total_pos = Total_pos + Added_pos;
    }

    Total_pos = Total_pos / num_on;
    F = Total_F;
    pos = Total_pos;
}

void Propulsion_System::get_thruster_force(int index, double F[3], double pos[3])
    //Description:   Gets the force and position of a specific thruster.
    //Preconditions: Valid thruster index must be provided.
    //Postconditions: Force and position of the thruster are returned.
{
    thrusters[index].get_force(available_mass, F, pos);
}

void Propulsion_System::get_thruster_force(int index, Vector3d F, Vector3d pos)
    //Description:   Overloaded version of get_thruster_force using Eigen vectors.
    //Preconditions: Valid thruster index must be provided.
    //Postconditions: Force and position of the thruster are returned.
{
    thrusters[index].get_force(available_mass, F, pos);
}

void Propulsion_System::turn_thruster_on(int index)
    //Description:   Turns a specific thruster on.
    //Preconditions: Valid thruster index must be provided.
    //Postconditions: The thruster is turned on.
{
    thrusters[index].switch_stateon();
}

void Propulsion_System::turn_all_on()
    //Description:   Turns all thrusters on.
    //Preconditions: None
    //Postconditions: All thrusters are turned on.
{
    for (int i = 0; i < 7; i++) {
        thrusters[i].switch_stateon();
    }
}

void Propulsion_System::turn_thruster_off(int index)
    //Description:   Turns a specific thruster off.
    //Preconditions: Valid thruster index must be provided.
    //Postconditions: The thruster is turned off.
{
    thrusters[index].switch_stateoff();
}

void Propulsion_System::turn_all_off()
    //Description:   Turns all thrusters off.
    //Preconditions: None
    //Postconditions: All thrusters are turned off.
{
    for (int i = 0; i < 7; i++) {
        thrusters[i].switch_stateoff();
    }
}

double Propulsion_System::state_deriv_getTotalMassflow()
    //Description:   Calculates and returns the total mass flow rate from all active thrusters.
    //Preconditions: None
    //Postconditions: Total mass flow rate is calculated and returned.
{
    total_massflow = 0;
    for (int i = 0; i < 7; i++) {
        if (thrusters[i].is_state_on()) {
            total_massflow = total_massflow + thrusters[i].get_massflow();
        }
    }
    return total_massflow;
}

double Propulsion_System::get_current_tankmass()
    //Description:   Returns the current xenon mass from the first available tank. Used as state derivative
    //Preconditions: None
    //Postconditions: Returns the mass of the first tank that has remaining mass, or 0 if all tanks are empty.
{
    if (tanks[0].getmass() > 0.0)
        return tanks[0].getmass();
    else if (tanks[1].getmass() > 0.0)
        return tanks[1].getmass();
    else if (tanks[2].getmass() > 0.0)
        return tanks[2].getmass();
    else
        return 0.0;
}

void Propulsion_System::update_tankmass(double current_mass)
    //Description:   Updates the current xenon mass in the first available tank. Used after integration
    //Preconditions: Valid current mass value must be provided.
    //Postconditions: Updates the tank's mass and recalculates the total available mass.
{
    if (tanks[0].getmass() > 0.0) {
        tanks[0].update_mass(current_mass);
        available_mass = tanks[0].getmass() + tanks[1].getmass() + tanks[2].getmass();
    } else if (tanks[1].getmass() > 0.0) {
        tanks[1].update_mass(current_mass);
        available_mass = tanks[0].getmass() + tanks[1].getmass() + tanks[2].getmass();
    } else if (tanks[2].getmass() > 0.0) {
        tanks[2].update_mass(current_mass);
        available_mass = tanks[0].getmass() + tanks[1].getmass() + tanks[2].getmass();
    } else {
        available_mass = 0.0;
    }
}


